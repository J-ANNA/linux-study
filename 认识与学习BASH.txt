认识与学习BASH

终端机的环境设置：stty,set
stty [-a]
参数：
-a: 将目前所有的 stty 参数列出来
例：
stty erase ^h   //用[Ctrl]+h 来进行字符的删除

set [-uvCHhmBx]
参数：
-u: 默认不启用，若启用后，当使用未设置变量时，会显示错误信息；
-v: 默认不启用，若启用后，在讯息被输出前，会显示信息的原始内容；
-x: 默认不启用，若启用后，在命令被执行前，会显示命令内容（前面有 ++ 符号）；
-h: 默认启用，与历史命令有关；
-m: 默认启用，与工作管理有关；
-B: 默认启用，与括号 [] 的作用有关；
-C: 默认不启用，使用 > 等时，则若文件存在时，该文件不会被覆盖。

范例：
echo $-  //显示目前所有的 set 设置的值
set -u
set -x 


bash默认的组合按键
[Ctrl]+c: 终止目前的命令
[Ctrl]+d: 输入结束(EOF),例如邮件结束的时候
[Ctrl]+m: Enter
[Ctrl]+s: 暂停屏幕输出
[Ctrl]+q: 恢复屏幕输出
[Ctrl]+u: 在提示符下，将整行命令删除
[Ctrl]+z: 暂停目前的命令


通配符
*: 代表0个到无穷多个任意字符
?: 代表一定有一个任意字符
[]:同样代表一定有一个在中括号内的字符（非任意字符）。例如[abcd]代表一定有一个字符，可能是a,b,c,d这四个任何一个
[-]: 若有减号在中括号内，代表在编码顺序内的所有字符。例如[0-9]代表0到9之间的所有数字。因为数字的预习编码是连续的
[^]: 若中括号内的第一个字符为指数符号(^),那表示反向选择，例如[^abc]代表一定有一个字符，只要是非a,b,c的其他字符就接受的意思


特殊符号
#: 批注符号
\: 转义符号
|：管道（pipe）,分隔两个管道命令的界定
;：连续命令执行分隔符，连续性命令的界定（注意，与管道命令并不相同）
~: 用户的主文件夹
$: 使用变量前导符，即变量之前需要加的变量替代值
&：作业控制（job control),将命令变成背景下工作
!: 逻辑运算意义上的“非”(not)的意思
/: 目录符号，路径分隔符
>,>>: 数据流重定向，输出导向，分别是“替换”与“累加”
<,<<: 数据流重定向，输入导向
'': 单引号，不具有变量置换的功能
"": 双引号，具有变量置换的功能
``: 两个 ' 中间为可以先执行的命令，也可以使用 $()
( ): 在中间为子 shell 的起始与结束
{ }：中间为命令块的组合


数据流重定向
1. 标准输入(stdin): 代码为0，使用< 或 <<;(<:替换；<<:累加)
2. 标准输出(stdout): 代码为1，使用 > 或 >>;
3. 标准错误输出(stderr): 代码为2，使用 2> 或 2>>

范例：
find /home -name .bashrc > list_right 2> list_error  //将stdout 与 stderr 分别存到不同的文件去

/dev/null 垃圾桶黑洞设备与特殊写法
范例：
find /home -name .bashrc 2> /dev/null  //将错误的数据丢弃，屏幕上显示正确的数据

//将命令的数据（正确+错误）全部写入同一文件
find /home -name .bashrc > list 2> list  //错误
find /home -name .bashrc > list 2> &1  //正确
find /home -name .bashrc &> list   //正确

范例：
cat > catfile < ~/.bashrc
cat > catfile << "eof"


命令执行的判断依据： ;, &&, ||
(1) cmd;cmd
(2)$?(命令回传值) 与&& 或 ||
若前一个命令执行的结果为正确，会回传一个$=0的值。


管线命令(pipe)
例：ls -al /etc | less
管线命令需要注意的地方：
(1)管线命令仅会处理standard output,对于standard error output会予以忽略；
(2)管线命令必须能够接受来自前一个指令的数据成为standard input继续处理才行。

撷取命令：cut,grep
cut:
cut -d '分隔符' -f fields  //用于有特定分隔字符
cut -c 字符区间   //用于排列整齐的讯息
选项参数：
-d: 后面接分隔字符。与 -f 一起使用;
-f: 依据 -d 的分隔字符将一段讯息分割成数段，用 -f 取出第几段的意思；
-c: 以字符(characters)的单位取出固定字符区间
范例：
echo $PATH | cut -d ';' -f 5   //第5段
echo $PATH | cut -d ';' -f 3,5 //第3和5段
export | cut -c 12-  //取得第12字符以后的所有字符
export | cut -c 12-20  //取得第12-20的字符
（cut 主要的用途在于将同一行里面的数据进行分解）

grep:
grep [-acinv] [--color=auto] '搜寻字符串' filename
选项与参数：
-a: 将binary文档以text文档的方式搜寻数据
-c: 计算找到'搜寻字符串'的次数
-i: 忽略大小写的不同，所以大小写视为相同
-n: 顺便输出行号
-v: 反向选择，亦即显示出没有'搜寻字符串'内容的那一行
--color=auto: 可以将找到的关键词部分加上颜色的显示















